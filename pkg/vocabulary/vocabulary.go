package vocabulary

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"
)

const generatedMessage = "This file was generated by github.com/leonhfr/vocabulary-action and is susceptible to be modified by automations."

const summaryLength = 10

type Logger interface {
	Info(msg string, args ...any)
	Warn(msg string, args ...any)
	Error(msg string, args ...any)
}

type Input struct {
	Language   string
	Vocabulary string
	Workspace  string
}

type Output struct {
	Directory string
	Summary   string
}

type Runner interface {
	Run(input Input, logger Logger, fh FileHandler) (Output, error)
}

type Handler struct{}

func (Handler) Run(input Input, logger Logger, fh FileHandler) (Output, error) {
	cfg, err := newConfig(input.Workspace)
	if err != nil {
		return Output{}, err
	}

	languageDir := cfg.languageDirectory(input.Language)
	logger.Info(fmt.Sprintf("language \"%s\", target directory \"%s\"", input.Language, languageDir))
	targetDir := filepath.Join(input.Workspace, languageDir)

	lines, err := readLines(strings.NewReader(input.Vocabulary))
	if err != nil {
		return Output{}, err
	}

	vocabulary, discarded := parseVocabulary(lines)
	for _, d := range discarded {
		logger.Error(fmt.Sprintf("discarded \"%s\"", d))
	}

	var errs []error
	wg := sync.WaitGroup{}

	for r, v := range vocabularyBuckets(vocabulary) {
		wg.Add(1)

		go func(r rune, v []string) {
			defer wg.Done()

			logger.Info("adding vocabulary to file %s/%c", targetDir, r)

			if err := bucketHandler(targetDir, r, v, fh); err != nil {
				errs = append(errs, err)
			}
		}(r, v)
	}

	wg.Wait()

	if len(errs) > 0 {
		return Output{}, fmt.Errorf("handlers: %w", errors.Join(errs...))
	}

	return Output{
		Directory: languageDir,
		Summary:   formatSummary(vocabulary),
	}, nil
}

func bucketHandler(dir string, r rune, vocabulary []string, fh FileHandler) error {
	filename := fmt.Sprintf("%c.md", r)
	existing, err := existingVocabulary(dir, filename, fh)
	if err != nil {
		return err
	}

	vocabulary = append(vocabulary, existing...)
	alphabeticalSort(vocabulary)

	contents := formatVocabularyFile(r, vocabulary)
	return fh.Write(dir, filename, contents)
}

func existingVocabulary(dir, filename string, fh FileHandler) ([]string, error) {
	contents, err := fh.Read(dir, filename)
	if errors.Is(err, fs.ErrNotExist) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	lines, err := readLines(strings.NewReader(contents))
	if err != nil {
		return nil, err
	}

	vocabulary, _ := parseVocabulary(lines)
	return vocabulary, nil
}

func parseVocabulary(lines []string) ([]string, []string) {
	var accepted []string
	var discarded []string
	for _, line := range lines {
		if _, ok := firstRuneIsLetter(line); ok {
			accepted = append(accepted, line)
		} else {
			discarded = append(discarded, line)
		}
	}
	return accepted, discarded
}

func formatVocabularyFile(r rune, vocabulary []string) string {
	return fmt.Sprintf("<!-- %s -->\n\n# %c\n\n%s", generatedMessage, r, strings.Join(vocabulary, "\n"))
}

func formatSummary(vocabulary []string) string {
	alphabeticalSort(vocabulary)
	summary := make([]string, 0, len(vocabulary))

	for _, line := range vocabulary {
		var word []string
		for _, f := range strings.Fields(line) {
			if _, ok := firstRuneIsLetter(f); !ok {
				break
			}
			word = append(word, f)
		}
		summary = append(summary, strings.Join(word, " "))
	}

	if len(summary) < summaryLength {
		return strings.Join(summary, ", ")
	}

	return strings.Join(summary[:summaryLength], ", ")
}

func vocabularyBuckets(vocabulary []string) map[rune][]string {
	buckets := map[rune][]string{}
	for _, word := range vocabulary {
		if r, ok := firstRuneIsLetter(word); ok {
			buckets[r] = append(buckets[r], word)
		}
	}
	return buckets
}

func alphabeticalSort(slice []string) {
	sort.Slice(slice, func(i, j int) bool {
		li := strings.ToLower(slice[i])
		lj := strings.ToLower(slice[j])
		if li == lj {
			return slice[i] < slice[j]
		}
		return li < lj
	})
}

func firstRuneIsLetter(line string) (rune, bool) {
	r, _ := utf8.DecodeRuneInString(line)
	if r == utf8.RuneError {
		return 0, false
	}
	return unicode.ToLower(r), unicode.IsLetter(r)
}

func readLines(r io.Reader) ([]string, error) {
	var lines []string
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		if line := scanner.Text(); line != "" {
			lines = append(lines, line)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return lines, nil
}
