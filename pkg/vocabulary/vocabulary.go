package vocabulary

import (
	"errors"
	"fmt"
	"io/fs"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/spf13/viper"
)

const (
	configFile       = "vocabulary"
	configLanguages  = "languages"
	defaultLanguage  = "default"
	defaultDirectory = "todo/vocabulary"
	generatedMessage = "This file was generated by github.com/leonhfr/vocabulary-action and is susceptible to be modified by automations."
	summaryLength    = 10
)

func LanguageDirectory(language string, config map[string]string) string {
	directory, ok := config[language]
	if ok {
		return directory
	}

	directory, ok = config[defaultLanguage]
	if ok {
		return directory
	}

	return defaultDirectory
}

func ParseConfig(workspace string) map[string]string {
	viper.AddConfigPath(workspace)
	viper.SetConfigName(configFile)

	err := viper.ReadInConfig()
	if err != nil {
		return map[string]string{}
	}

	return viper.GetStringMapString(configLanguages)
}

func Filter(paragraphs []string) (accepted []string, discarded []string) {
	for _, p := range paragraphs {
		if _, ok := firstRuneIsLetter(p); ok {
			accepted = append(accepted, p)
		} else {
			discarded = append(discarded, p)
		}
	}
	return
}

func Buckets(vocabulary []string) map[rune][]string {
	buckets := map[rune][]string{}
	for _, word := range vocabulary {
		if r, ok := firstRuneIsLetter(word); ok {
			buckets[r] = append(buckets[r], word)
		}
	}
	return buckets
}

func Existing(dir, filename string, fh FileHandler) (string, error) {
	contents, err := fh.Read(dir, filename)
	if errors.Is(err, fs.ErrNotExist) {
		return "", nil
	}
	return contents, err
}

func Merge(old, new []string) []string {
	next := append(old, new...)
	alphabeticalSort(next)
	return next
}

func Upsert(dir, filename string, vocabulary []string, fh FileHandler) error {
	contents := fmt.Sprintf("<!-- %s -->\n\n%s\n", generatedMessage, strings.Join(vocabulary, "\n\n"))
	return fh.Write(dir, filename, contents)
}

func Summary(vocabulary []string) string {
	alphabeticalSort(vocabulary)
	summary := make([]string, 0, len(vocabulary))

	for _, line := range vocabulary {
		var word []string
		for _, f := range strings.Fields(line) {
			if _, ok := firstRuneIsLetter(f); !ok {
				break
			}
			word = append(word, f)
		}
		summary = append(summary, strings.Join(word, " "))
	}

	if len(summary) < summaryLength {
		return strings.Join(summary, ", ")
	}

	return strings.Join(summary[:summaryLength], ", ")
}

func alphabeticalSort(slice []string) {
	sort.Slice(slice, func(i, j int) bool {
		li := strings.ToLower(slice[i])
		lj := strings.ToLower(slice[j])
		if li == lj {
			return slice[i] < slice[j]
		}
		return li < lj
	})
}

func firstRuneIsLetter(line string) (rune, bool) {
	r, _ := utf8.DecodeRuneInString(line)
	if r == utf8.RuneError {
		return 0, false
	}
	return unicode.ToLower(r), unicode.IsLetter(r)
}
