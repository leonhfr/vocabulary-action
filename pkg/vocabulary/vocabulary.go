package vocabulary

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"
)

const generatedMessage = "This file was generated by github.com/leonhfr/vocabulary-action and is susceptible to be modified by automations."

const summaryLength = 10

type Input struct {
	Language   string
	Vocabulary string
	Workspace  string
}

type Output struct {
	Directory string
	Summary   string
}

type Runner interface {
	Run(input Input) (Output, error)
}

type Handler struct{}

func (Handler) Run(_ Input) (Output, error) {
	return Output{}, nil
}

func bucketHandler(dir string, r rune, vocabulary []string, fh FileHandler) error {
	filename := fmt.Sprintf("%c.md", r)
	existing, err := existingVocabulary(dir, filename, fh)
	if err != nil {
		return err
	}

	vocabulary = append(vocabulary, existing...)
	alphabeticalSort(vocabulary)

	contents := formatVocabularyFile(r, vocabulary)
	return fh.Write(dir, filename, contents)
}

func existingVocabulary(dir, filename string, fh FileHandler) ([]string, error) {
	contents, err := fh.Read(dir, filename)
	if errors.Is(err, fs.ErrNotExist) {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	lines, err := readLines(strings.NewReader(contents))
	if err != nil {
		return nil, err
	}

	vocabulary, _ := parseVocabulary(lines)
	return vocabulary, nil
}

func parseVocabulary(lines []string) ([]string, []string) {
	var accepted []string
	var discarded []string
	for _, line := range lines {
		if _, ok := firstRuneIsLetter(line); ok {
			accepted = append(accepted, line)
		} else {
			discarded = append(discarded, line)
		}
	}
	return accepted, discarded
}

func formatVocabularyFile(r rune, vocabulary []string) string {
	return fmt.Sprintf("<!-- %s -->\n\n# %c\n\n%s", generatedMessage, r, strings.Join(vocabulary, "\n"))
}

func formatSummary(vocabulary []string) string {
	alphabeticalSort(vocabulary)
	summary := make([]string, 0, len(vocabulary))

	for _, line := range vocabulary {
		var word []string
		for _, f := range strings.Fields(line) {
			if _, ok := firstRuneIsLetter(f); !ok {
				break
			}
			word = append(word, f)
		}
		summary = append(summary, strings.Join(word, " "))
	}

	if len(summary) < summaryLength {
		return strings.Join(summary, ", ")
	}

	return strings.Join(summary[:summaryLength], ", ")
}

func vocabularyBuckets(vocabulary []string) map[rune][]string {
	buckets := map[rune][]string{}
	for _, word := range vocabulary {
		if r, ok := firstRuneIsLetter(word); ok {
			buckets[r] = append(buckets[r], word)
		}
	}
	return buckets
}

func alphabeticalSort(slice []string) {
	sort.Slice(slice, func(i, j int) bool {
		li := strings.ToLower(slice[i])
		lj := strings.ToLower(slice[j])
		if li == lj {
			return slice[i] < slice[j]
		}
		return li < lj
	})
}

func firstRuneIsLetter(line string) (rune, bool) {
	r, _ := utf8.DecodeRuneInString(line)
	if r == utf8.RuneError {
		return 0, false
	}
	return unicode.ToLower(r), unicode.IsLetter(r)
}

func readLines(r io.Reader) ([]string, error) {
	var lines []string
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		if line := scanner.Text(); line != "" {
			lines = append(lines, line)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return lines, nil
}
